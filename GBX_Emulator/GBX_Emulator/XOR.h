#pragma once

#include <windows.h>
#include <stdint.h>
#include <vector>

using namespace std;

//const BYTE key_1 = 0xB7;

const BYTE key_256[256] = {
	0x56,0x28,0x67,0x30,0x1D,0xB1,0xD8,0xEA,0x0D,0x00,0x32,0xF5,0xAA,0xAF,0x7F,0x8C,0x6F,0x2A,0xF9,0x71,0x38,0x93,0xB9,0x5A,0xAF,0xEF,0xE4,0x34,0xB4,0x32,0x83,0x10,
	0xF3,0x5C,0x67,0x58,0xBD,0x8F,0x44,0xCA,0xF6,0xC6,0xCB,0x5B,0xA8,0x91,0x27,0x96,0xF2,0x57,0x70,0x5B,0xBC,0x0D,0x26,0xC4,0x51,0x19,0x9F,0x8C,0x3B,0xE8,0x8D,0x4C,
	0xA0,0xEC,0x05,0x7E,0xFD,0x08,0x1F,0x08,0x8E,0x51,0x18,0xF9,0x72,0x22,0xAF,0xA2,0x36,0xCA,0x86,0x08,0x32,0x7B,0x85,0x14,0x38,0x3E,0xE3,0xB1,0xA7,0x33,0x01,0x5D,
	0x26,0xF6,0x6B,0x94,0xB6,0x63,0xAD,0x6B,0x25,0x76,0x3F,0x4C,0x49,0x98,0xE8,0x61,0x54,0xA5,0x45,0x55,0xE3,0x25,0x9A,0x85,0xE5,0x62,0x05,0x23,0x8D,0x74,0xDD,0x4B,
	0x48,0x42,0x7A,0xB0,0x30,0xD9,0xE9,0x35,0x5A,0x1B,0x94,0x0A,0xFD,0x45,0x45,0x37,0x33,0x1B,0x63,0x25,0x85,0xF1,0xB0,0xB9,0xD3,0xA7,0xBC,0xCA,0x75,0x89,0xEF,0xEB,
	0x27,0x2F,0x63,0x14,0xF0,0x1F,0xC6,0x54,0x50,0xEE,0xEC,0x9E,0xDA,0xC2,0xD5,0xA3,0xA2,0x67,0x54,0xBD,0x64,0x7A,0x71,0xE1,0x37,0x15,0xC1,0x32,0x56,0x01,0x10,0xA2,
	0x12,0x2E,0x39,0x70,0x1C,0xA4,0x74,0xEC,0xDA,0xE3,0xB5,0xA0,0x05,0x54,0x10,0xC5,0x0D,0xB7,0x13,0x2A,0x8C,0xD9,0x22,0x4F,0xC8,0x19,0xB6,0x53,0xF5,0xAC,0xF1,0xE3,
	0x19,0xA4,0x32,0x33,0x11,0xD3,0x73,0x67,0xCD,0x5B,0xF1,0x12,0x4C,0xF0,0xF7,0x3B,0x34,0x0D,0x28,0x76,0x22,0xE2,0x8A,0x3A,0x22,0xE0,0x68,0x8A,0xFE,0xBC,0xBC,0x21,
};

class XOR
{
private:
	XOR();
	~XOR();
public:
	//static void xor_1byte(BYTE* buffer, uint32_t buffer_size) {
	//	for (uint32_t i = 0; i < buffer_size; i++) {
	//		buffer[i] ^= key_1;
	//	}
	//}

	static void xor_256byte(BYTE* buffer, uint32_t buffer_size) {
		uint32_t key_index = 0;
		for (uint32_t i = 0; i < buffer_size; i++) {
			buffer[i] ^= key_256[key_index];
			key_index++;
			key_index %= 256;
		}
	}

};
